create extension vector
with
  schema extensions;

-- Create a table for public profiles
create table userprofiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  first_name text,
  last_name text,
  avatar_url text,
  location text,
  summary text,
  skills text array
);

-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/auth/row-level-security for more details.
alter table userprofiles
  enable row level security;

create policy "Public profiles are viewable by everyone." on userprofiles
  for select using (true);

create policy "Users can insert their own profile." on userprofiles
  for insert with check ((select auth.uid()) = id);

create policy "Users can update own profile." on userprofiles
  for update using ((select auth.uid()) = id);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers for more details.
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
begin
  insert into public.userprofiles (id, email)
  values (new.id, new.email);
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Set up avatar storage
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- Set up access controls for storage
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');

-- Set up logo storage
insert into storage.buckets (id, name)
  values ('logos', 'logos');

-- Set up access controls for storage
create policy "Logo images are publicly accessible." on storage.objects
  for select using (bucket_id = 'logos');

create policy "Anyone can upload a logo." on storage.objects
  for insert with check (bucket_id = 'logos');

-- User Educations
create table usereducations (
  id bigint generated by default as identity primary key,
  school text,
  degree text,
  location text,
  gpa text,
  description text,
  start_date date,
  end_date date,
  userid uuid not null references public.userprofiles
);

alter table usereducations
  enable row level security;

create policy "Public educations are viewable by everyone." on usereducations
  for select using (true);

create policy "Users can insert their own education." on usereducations
  for insert with check ((select auth.uid()) = userid);

create policy "Users can update own education." on usereducations
  for update using ((select auth.uid()) = userid);

create policy "Users can delete own education." on usereducations
  for delete using ((select auth.uid()) = userid);

-- User Experiences
create table userexperiences (
  id bigint generated by default as identity primary key,
  company text,
  title text,
  location text,
  description text,
  start_date date,
  end_date date,
  userid uuid not null references public.userprofiles
);

alter table userexperiences
  enable row level security;

create policy "Public experiences are viewable by everyone." on userexperiences
  for select using (true);

create policy "Users can insert their own experience." on userexperiences
  for insert with check ((select auth.uid()) = userid);

create policy "Users can update own experience." on userexperiences
  for update using ((select auth.uid()) = userid);

create policy "Users can delete own experience." on userexperiences
  for delete using ((select auth.uid()) = userid);

-- Company Profiles and Employees
create table companyprofiles (
  id bigint generated by default as identity primary key,
  company_name text,
  location text,
  logo_url text,
  description text
);

alter table companyprofiles
  enable row level security;

create policy "Company profiles are viewable by everyone." on companyprofiles
  for select using (true);

create policy "Companies can be created by everyone." on companyprofiles
  for insert with check (true);

-- Table to map company-employee relationship
create table companyemployees (
  companyid bigint not null references public.companyprofiles,
  userid uuid not null references public.userprofiles,

  primary key(companyid, userid)
);

alter table companyemployees
  enable row level security;

create function is_company_employee(uid uuid, cid bigint)
returns boolean
set search_path = ''
as $$
begin
  return exists(select 1 from public.companyemployees where userid = uid and companyid = cid);
end;
$$ language plpgsql;

create policy "Company employees are viewable by everyone." on companyemployees
  for select using (true);

create policy "Employees can update their own company." on companyprofiles
  for update using (is_company_employee((select auth.uid()), id));

create policy "Employees can add other employees to their own company." on companyemployees
  for insert with check (is_company_employee((select auth.uid()), companyid));

-- Trigger for making user who created company an employee
create function public.handle_new_company()
returns trigger
set search_path = ''
as $$
begin
  insert into public.companyemployees (companyid, userid)
  values (new.id, auth.uid());
  return new;
end;
$$ language plpgsql security definer;
create trigger on_company_created
  after insert on public.companyprofiles
  for each row execute procedure public.handle_new_company();

-- Job Postings
create type jobtype as enum ('Full-time', 'Part-time', 'Contract', 'Temporary', 'Internship', 'Remote');

create table jobpostings (
  id bigint generated by default as identity primary key,
  title text,
  location text,
  description text,
  posted_date timestamptz,
  job_type jobtype,
  salary_range text,
  companyid bigint not null references public.companyprofiles
);

alter table jobpostings
  enable row level security;

create policy "Job postings are viewable by everyone." on jobpostings
  for select using (true);

create policy "Company employees can create their own job postings." on jobpostings
  for insert with check (is_company_employee((select auth.uid()), companyid));

create policy "Company employees can update their own job postings." on jobpostings
  for update using (is_company_employee((select auth.uid()), companyid));

create policy "Company employees can delete their own postings." on jobpostings
  for delete using (is_company_employee((select auth.uid()), companyid));

-- Job Applications
create type jobapplicationstatus as enum ('applied', 'withdrawn', 'not selected', 'interview', 'offer');

create table jobapplications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  jobid bigint not null references public.jobpostings,
  companyid bigint not null references public.companyprofiles,
  userid uuid not null references public.userprofiles,
  application_status jobapplicationstatus default 'applied',
  application_date timestamptz,
  unique (jobid, userid)
);

alter table jobapplications
  enable row level security;

create policy "Job applications are only viewable by company or applicant." on jobapplications
  for select using ((select auth.uid()) = userid or is_company_employee((select auth.uid()), companyid));

create policy "Users can insert their own application." on jobapplications
  for insert with check ((select auth.uid()) = userid);

create policy "Users or company employees can update their own application." on jobapplications
  for update using ((select auth.uid()) = userid or is_company_employee((select auth.uid()), companyid));

create policy "Users can delete their own application." on jobapplications
  for delete using ((select auth.uid()) = userid);

-- User and Job Embeddings
create table userprofileembeddings (
  id uuid references userprofiles not null primary key,
  embedding_gemini_te004 vector(768)
);

alter table userprofileembeddings
  enable row level security;

create policy "User profile embeddings are viewable by everyone." on userprofileembeddings
  for select using (true);

create table jobpostingembeddings (
  id bigint references jobpostings not null primary key,
  embedding_gemini_te004 vector(768)
);

alter table jobpostingembeddings
  enable row level security;

create policy "Job posting embeddings are viewable by everyone." on jobpostingembeddings
  for select using (true);

-- Embedding Operations
create or replace function get_match_percent(user_id uuid, job_id bigint)
returns float
as $$
declare
  user_embedding vector(768);
  job_embedding vector(768);
begin
  -- 1. Get user's embedding
  select embedding_gemini_te004
  into user_embedding
  from userprofileembeddings
  where userprofileembeddings.id = user_id;

  -- 2. Get job's embedding
  select embedding_gemini_te004
  into job_embedding
  from jobpostingembeddings
  where jobpostingembeddings.id = job_id;

  return 1 - (user_embedding <=> job_embedding);
end;
$$ language plpgsql;

-- Functions for Fetching Embedding-related Data
create or replace function fetch_paginated_jobs4user ( -- This is fetching jobs for a particular user
  user_id uuid,
  query text,
  sortby text,
  sortorder text,
  companyid_opt bigint default null,
  page_start int default 0,
  page_limit int default 6
)
returns table (
  id bigint,
  title text,
  location text,
  description text,
  posted_date timestamptz,
  job_type jobtype,
  salary_range text,
  companyid bigint,
  company_name text,
  logo_url text,
  match_percent float
)
as $$
declare
  user_embedding vector(768);
  sort_column text;
  sort_direction text;
  base_query text;
begin
  -- 1. Validate and normalize sort column
  sort_column := case lower(sortby)
    when 'posted_date' then 'posted_date'
    when 'match_percent' then 'match_percent'
    else 'match_percent'  -- default
  end;

  -- 2. Validate and normalize sort direction
  sort_direction := case lower(sortorder)
    when 'asc' then 'ASC'
    when 'desc' then 'DESC'
    else 'DESC'  -- default
  end;

  -- 3. Get user's embedding
  select embedding_gemini_te004
  into user_embedding
  from userprofileembeddings
  where userprofileembeddings.id = user_id;

  -- 4. Build base query using format-safe dynamic SQL
  base_query := format($f$
    select
      jobs.id,
      jobs.title,
      jobs.location,
      jobs.description,
      jobs.posted_date,
      jobs.job_type,
      jobs.salary_range,
      jobs.companyid,
      companies.company_name,
      companies.logo_url,
      coalesce(1 - (job_embeds.embedding_gemini_te004 <=> $1), 0.5) as match_percent
    from jobpostings jobs
    left join jobpostingembeddings job_embeds on jobs.id = job_embeds.id
    join companyprofiles companies on jobs.companyid = companies.id
    where (jobs.title ilike '%%' || $2 || '%%'
       or jobs.description ilike '%%' || $2 || '%%') %s
    order by %I %s
    offset $3
    limit $4
  $f$,
  case
    when companyid_opt is not null then 'and jobs.companyid = $5'
    else ''
  end,
  sort_column,
  sort_direction
  );

  -- 5. Execute the safe dynamic query
  if companyid_opt is not null then
    return query execute base_query
    using user_embedding, query, page_start, page_limit, companyid_opt;
  else
    return query execute base_query
    using user_embedding, query, page_start, page_limit;
  end if;
end;
$$ language plpgsql;

create or replace function fetch_paginated_users4job ( -- This is for "suggested" users...
  job_id bigint,
  page_start int default 0,
  page_limit int default 6
)
returns table (
  id uuid,
  email text,
  first_name text,
  last_name text,
  location text,
  summary text,
  skills text[],
  avatar_url text,
  match_percent float,
  applicationid uuid,
  application_status jobapplicationstatus
)
as $$
declare
  job_embedding vector(768);
begin
  -- 1. Get job's embedding
  select embedding_gemini_te004
  into job_embedding
  from jobpostingembeddings
  where jobpostingembeddings.id = job_id;

  -- 2. Execute the query
  return query
  with apps as (select * from jobapplications where jobapplications.jobid = job_id)
  select
      profiles.id,
      profiles.email,
      profiles.first_name,
      profiles.last_name,
      profiles.location,
      profiles.summary,
      profiles.skills,
      profiles.avatar_url,
      coalesce(1 - (user_embeds.embedding_gemini_te004 <=> job_embedding), 0) as match_percent,
      apps.id as applicationid,
      apps.application_status
    from userprofiles profiles
    left join userprofileembeddings user_embeds on profiles.id = user_embeds.id
    left join apps on profiles.id = apps.userid
    order by match_percent desc
    offset page_start
    limit page_limit;
end;
$$ language plpgsql;

create or replace function fetch_paginated_apps4job ( -- This is for applications for the given job
  job_id bigint,
  query text,
  sortby text,
  sortorder text,
  page_start int default 0,
  page_limit int default 6
)
returns table (
  id uuid,
  application_status jobapplicationstatus,
  application_date timestamptz,
  userid uuid,
  email text,
  first_name text,
  last_name text,
  location text,
  summary text,
  skills text[],
  avatar_url text,
  match_percent float
)
as $$
declare
  job_embedding vector(768);
  sort_column text;
  sort_direction text;
  base_query text;
begin
  -- 1. Validate and normalize sort column
  sort_column := case lower(sortby)
    when 'application_date' then 'application_date'
    when 'match_percent' then 'match_percent'
    else 'match_percent'  -- default
  end;

  -- 2. Validate and normalize sort direction
  sort_direction := case lower(sortorder)
    when 'asc' then 'ASC'
    when 'desc' then 'DESC'
    else 'DESC'  -- default
  end;

  -- 3. Get job's embedding
  select embedding_gemini_te004
  into job_embedding
  from jobpostingembeddings
  where jobpostingembeddings.id = job_id;

  -- 4. Build base query using format-safe dynamic SQL
  base_query := format($f$
    with apps as (select * from jobapplications where jobapplications.jobid = $1)
    select
      apps.id,
      apps.application_status,
      apps.application_date,
      apps.userid,
      profiles.email,
      profiles.first_name,
      profiles.last_name,
      profiles.location,
      profiles.summary,
      profiles.skills,
      profiles.avatar_url,
     coalesce(1 - (user_embeds.embedding_gemini_te004 <=> $2), 0.5) as match_percent
    from apps
    join userprofiles profiles on apps.userid = profiles.id
    left join userprofileembeddings user_embeds on profiles.id = user_embeds.id
    where profiles.first_name ilike '%%' || $3 || '%%'
       or profiles.last_name ilike '%%' || $3 || '%%'
       or profiles.email ilike '%%' || $3 || '%%'
    order by %I %s
    offset $4
    limit $5
  $f$, sort_column, sort_direction);

  -- 5. Execute the safe dynamic query
  return query execute base_query
  using job_id, job_embedding, query, page_start, page_limit;
end;
$$ language plpgsql;

create or replace function fetch_paginated_apps4user ( -- This is for apps to user
  user_id uuid,
  query text,
  sortby text,
  sortorder text,
  page_start int default 0,
  page_limit int default 6
)
returns table (
  id uuid,
  application_status jobapplicationstatus,
  application_date timestamptz,
  jobid bigint,
  title text,
  location text,
  description text,
  companyid bigint,
  company_name text,
  logo_url text,
  match_percent float
)
as $$
declare
  user_embedding vector(768);
  sort_column text;
  sort_direction text;
  base_query text;
begin
  -- 1. Validate and normalize sort column
  sort_column := case lower(sortby)
    when 'match_percent' then 'match_percent'
    when 'application_date' then 'application_date'
    else 'application_date'  -- default
  end;

  -- 2. Validate and normalize sort direction
  sort_direction := case lower(sortorder)
    when 'asc' then 'ASC'
    when 'desc' then 'DESC'
    else 'DESC'  -- default
  end;

  -- 3. Get user's embedding
  select embedding_gemini_te004
  into user_embedding
  from userprofileembeddings
  where userprofileembeddings.id = user_id;

  -- 4. Build base query using format-safe dynamic SQL
  base_query := format($f$
    with apps as (select * from jobapplications where jobapplications.userid = $1)
    select
      apps.id,
      apps.application_status,
      apps.application_date,
      apps.jobid,
      jobs.title,
      jobs.location,
      jobs.description,
      apps.companyid,
      companies.company_name,
      companies.logo_url,
      coalesce(1 - (job_embeds.embedding_gemini_te004 <=> $2), 0.5) as match_percent
    from apps
    join jobpostings jobs on apps.jobid = jobs.id
    left join jobpostingembeddings job_embeds on jobs.id = job_embeds.id
    join companyprofiles companies on apps.companyid = companies.id
    where jobs.title ilike '%%' || $3 || '%%'
       or companies.company_name ilike '%%' || $3 || '%%'
    order by %I %s
    offset $4
    limit $5
  $f$, sort_column, sort_direction);

  -- 5. Execute the safe dynamic query
  return query execute base_query
  using user_id, user_embedding, query, page_start, page_limit;
end;
$$ language plpgsql;